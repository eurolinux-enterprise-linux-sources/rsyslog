From 6267b5a57c432a3be68f362c571beb062d47b3a7 Mon Sep 17 00:00:00 2001
From: PascalWithopf <pwithopf@adiscon.com>
Date: Tue, 23 May 2017 15:32:34 +0200
Subject: [PATCH 10/11] omelasticsearch: replace cJSON with libfastjson

(cherry picked from commit 7982f50675471220c5ba035371a8f7537a50442b)
(cherry picked from commit 0b09c29db0cec5a215a95d03cfc37a27e486811c)
---
 plugins/omelasticsearch/Makefile.am       |   3 +-
 plugins/omelasticsearch/cJSON/cjson.c     | 525 ------------------------------
 plugins/omelasticsearch/cJSON/cjson.h     | 130 --------
 plugins/omelasticsearch/omelasticsearch.c | 171 +++++-----
 12 files changed, 84 insertions(+), 1323 deletions(-)
 delete mode 100644 plugins/omelasticsearch/cJSON/cjson.c
 delete mode 100644 plugins/omelasticsearch/cJSON/cjson.h

diff --git a/plugins/omelasticsearch/Makefile.am b/plugins/omelasticsearch/Makefile.am
index ba85a896d..2fadb74dc 100644
--- a/plugins/omelasticsearch/Makefile.am
+++ b/plugins/omelasticsearch/Makefile.am
@@ -1,7 +1,6 @@
 pkglib_LTLIBRARIES = omelasticsearch.la
 
-# TODO: replace cJSON
-omelasticsearch_la_SOURCES = omelasticsearch.c cJSON/cjson.c  cJSON/cjson.h
+omelasticsearch_la_SOURCES = omelasticsearch.c
 omelasticsearch_la_CPPFLAGS =  $(RSRT_CFLAGS) $(PTHREADS_CFLAGS)
 omelasticsearch_la_LDFLAGS = -module -avoid-version
 omelasticsearch_la_LIBADD =  $(CURL_LIBS) $(LIBM)
diff --git a/plugins/omelasticsearch/cJSON/cjson.c b/plugins/omelasticsearch/cJSON/cjson.c
deleted file mode 100644
index 6f7d43a23..000000000
--- a/plugins/omelasticsearch/cJSON/cjson.c
+++ /dev/null
@@ -1,525 +0,0 @@
-/*
-  Copyright (c) 2009 Dave Gamble
-
-  Permission is hereby granted, free of charge, to any person obtaining a copy
-  of this software and associated documentation files (the "Software"), to deal
-  in the Software without restriction, including without limitation the rights
-  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-  copies of the Software, and to permit persons to whom the Software is
-  furnished to do so, subject to the following conditions:
-
-  The above copyright notice and this permission notice shall be included in
-  all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-  THE SOFTWARE.
-*/
-
-/* this code has several warnings, but we ignore them because
- * this seems to work and we do not want to engage in that code body. If
- * we really run into troubles, it is better to change to libfastjson, which
- * we should do in the medium to long term anyhow...
- */
-#pragma GCC diagnostic ignored "-Wmissing-prototypes"
-#pragma GCC diagnostic ignored "-Wredundant-decls"
-#pragma GCC diagnostic ignored "-Wstrict-prototypes"
-#pragma GCC diagnostic ignored "-Wswitch-default"
-#pragma GCC diagnostic ignored "-Wold-style-definition"
-
-/* cJSON */
-/* JSON parser in C. */
-
-#include <string.h>
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#include <float.h>
-#include <limits.h>
-#include <ctype.h>
-#include "cjson.h"
-
-static const char *ep;
-
-const char *cJSON_GetErrorPtr() {return ep;}
-
-static int cJSON_strcasecmp(const char *s1,const char *s2)
-{
-	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
-	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
-	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
-}
-
-static void *(*cJSON_malloc)(size_t sz) = malloc;
-static void (*cJSON_free)(void *ptr) = free;
-
-static char* cJSON_strdup(const char* str)
-{
-      size_t len;
-      char* copy;
-
-      len = strlen(str) + 1;
-      if (!(copy = (char*)cJSON_malloc(len))) return 0;
-      memcpy(copy,str,len);
-      return copy;
-}
-
-void cJSON_InitHooks(cJSON_Hooks* hooks)
-{
-    if (!hooks) { /* Reset hooks */
-        cJSON_malloc = malloc;
-        cJSON_free = free;
-        return;
-    }
-
-	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
-	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
-}
-
-/* Internal constructor. */
-static cJSON *cJSON_New_Item()
-{
-	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
-	if (node) memset(node,0,sizeof(cJSON));
-	return node;
-}
-
-/* Delete a cJSON structure. */
-void cJSON_Delete(cJSON *c)
-{
-	cJSON *next;
-	while (c)
-	{
-		next=c->next;
-		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
-		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
-		if (c->string) cJSON_free(c->string);
-		cJSON_free(c);
-		c=next;
-	}
-}
-
-/* Parse the input text to generate a number, and populate the result into item. */
-static const char *parse_number(cJSON *item,const char *num)
-{
-	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
-
-	/* Could use sscanf for this? */
-	if (*num=='-') sign=-1,num++;	/* Has sign? */
-	if (*num=='0') num++;			/* is zero */
-	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
-	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
-	if (*num=='e' || *num=='E')		/* Exponent? */
-	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
-		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
-	}
-
-	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
-	
-	item->valuedouble=n;
-	item->valueint=(int)n;
-	item->type=cJSON_Number;
-	return num;
-}
-
-/* Render the number nicely from the given item into a string. */
-char *cJSON_print_number(cJSON *item)
-{
-	char *str;
-	double d=item->valuedouble;
-	if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
-	{
-		str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
-		if (str) sprintf(str,"%d",item->valueint);
-	}
-	else
-	{
-		str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
-		if (str)
-		{
-			if (fabs(floor(d)-d)<=DBL_EPSILON)			sprintf(str,"%.0f",d);
-			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)	sprintf(str,"%e",d);
-			else										sprintf(str,"%f",d);
-		}
-	}
-	return str;
-}
-
-/* Parse the input text into an unescaped cstring, and populate item. */
-static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-static const char *parse_string(cJSON *item,const char *str)
-{
-	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
-	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
-	
-	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
-	
-	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
-	if (!out) return 0;
-	
-	ptr=str+1;ptr2=out;
-	while (*ptr!='\"' && *ptr)
-	{
-		if (*ptr!='\\') *ptr2++=*ptr++;
-		else
-		{
-			ptr++;
-			switch (*ptr)
-			{
-				case 'b': *ptr2++='\b';	break;
-				case 'f': *ptr2++='\f';	break;
-				case 'n': *ptr2++='\n';	break;
-				case 'r': *ptr2++='\r';	break;
-				case 't': *ptr2++='\t';	break;
-				case 'u':	 /* transcode utf16 to utf8. */
-					sscanf(ptr+1,"%4x",&uc);ptr+=4;	/* get the unicode char. */
-
-					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	// check for invalid.
-
-					if (uc>=0xD800 && uc<=0xDBFF)	// UTF16 surrogate pairs.
-					{
-						if (ptr[1]!='\\' || ptr[2]!='u')	break;	// missing second-half of surrogate.
-						sscanf(ptr+3,"%4x",&uc2);ptr+=6;
-						if (uc2<0xDC00 || uc2>0xDFFF)		break;	// invalid second-half of surrogate.
-						uc=0x10000 | ((uc&0x3FF)<<10) | (uc2&0x3FF);
-					}
-
-					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
-					
-					switch (len) {
-						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
-						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
-						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
-						case 1: *--ptr2 =(uc | firstByteMark[len]);
-					}
-					ptr2+=len;
-					break;
-				default:  *ptr2++=*ptr; break;
-			}
-			ptr++;
-		}
-	}
-	*ptr2=0;
-	if (*ptr=='\"') ptr++;
-	item->valuestring=out;
-	item->type=cJSON_String;
-	return ptr;
-}
-
-/* Render the cstring provided to an escaped version that can be printed. */
-static char *print_string_ptr(const char *str)
-{
-	const char *ptr;char *ptr2,*out;int len=0;unsigned char token;
-	
-	if (!str) return cJSON_strdup("");
-	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
-	
-	out=(char*)cJSON_malloc(len+3);
-	if (!out) return 0;
-
-	ptr2=out;ptr=str;
-	*ptr2++='\"';
-	while (*ptr)
-	{
-		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
-		else
-		{
-			*ptr2++='\\';
-			switch (token=*ptr++)
-			{
-				case '\\':	*ptr2++='\\';	break;
-				case '\"':	*ptr2++='\"';	break;
-				case '\b':	*ptr2++='b';	break;
-				case '\f':	*ptr2++='f';	break;
-				case '\n':	*ptr2++='n';	break;
-				case '\r':	*ptr2++='r';	break;
-				case '\t':	*ptr2++='t';	break;
-				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
-			}
-		}
-	}
-	*ptr2++='\"';*ptr2++=0;
-	return out;
-}
-/* Invote print_string_ptr (which is useful) on an item. */
-static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}
-
-/* Predeclare these prototypes. */
-static const char *parse_value(cJSON *item,const char *value);
-static char *print_value(cJSON *item,int depth,int fmt);
-static const char *parse_array(cJSON *item,const char *value);
-static char *print_array(cJSON *item,int depth,int fmt);
-static const char *parse_object(cJSON *item,const char *value);
-static char *print_object(cJSON *item,int depth,int fmt);
-
-/* Utility to jump whitespace and cr/lf */
-static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
-
-/* Parse an object - create a new root, and populate. */
-cJSON *cJSON_Parse(const char *value)
-{
-	cJSON *c=cJSON_New_Item();
-	ep=0;
-	if (!c) return 0;       /* memory fail */
-
-	if (!parse_value(c,skip(value))) {cJSON_Delete(c);return 0;}
-	return c;
-}
-
-/* Render a cJSON item/entity/structure to text. */
-char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}
-char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}
-
-/* Parser core - when encountering text, process appropriately. */
-static const char *parse_value(cJSON *item,const char *value)
-{
-	if (!value)						return 0;	/* Fail on null. */
-	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
-	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
-	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
-	if (*value=='\"')				{ return parse_string(item,value); }
-	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
-	if (*value=='[')				{ return parse_array(item,value); }
-	if (*value=='{')				{ return parse_object(item,value); }
-
-	ep=value;return 0;	/* failure. */
-}
-
-/* Render a value to text. */
-static char *print_value(cJSON *item,int depth,int fmt)
-{
-	char *out=0;
-	if (!item) return 0;
-	switch ((item->type)&255)
-	{
-		case cJSON_NULL:	out=cJSON_strdup("null");	break;
-		case cJSON_False:	out=cJSON_strdup("false");break;
-		case cJSON_True:	out=cJSON_strdup("true"); break;
-		case cJSON_Number:	out=cJSON_print_number(item);break;
-		case cJSON_String:	out=print_string(item);break;
-		case cJSON_Array:	out=print_array(item,depth,fmt);break;
-		case cJSON_Object:	out=print_object(item,depth,fmt);break;
-	}
-	return out;
-}
-
-/* Build an array from input text. */
-static const char *parse_array(cJSON *item,const char *value)
-{
-	cJSON *child;
-	if (*value!='[')	{ep=value;return 0;}	/* not an array! */
-
-	item->type=cJSON_Array;
-	value=skip(value+1);
-	if (*value==']') return value+1;	/* empty array. */
-
-	item->child=child=cJSON_New_Item();
-	if (!item->child) return 0;		 /* memory fail */
-	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
-	if (!value) return 0;
-
-	while (*value==',')
-	{
-		cJSON *new_item;
-		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
-		child->next=new_item;new_item->prev=child;child=new_item;
-		value=skip(parse_value(child,skip(value+1)));
-		if (!value) return 0;	/* memory fail */
-	}
-
-	if (*value==']') return value+1;	/* end of array */
-	ep=value;return 0;	/* malformed. */
-}
-
-/* Render an array to text */
-static char *print_array(cJSON *item,int depth,int fmt)
-{
-	char **entries;
-	char *out=0,*ptr,*ret;int len=5;
-	cJSON *child=item->child;
-	int numentries=0,i=0,fail=0;
-	
-	/* How many entries in the array? */
-	while (child) numentries++,child=child->next;
-	/* Allocate an array to hold the values for each */
-	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
-	if (!entries) return 0;
-	memset(entries,0,numentries*sizeof(char*));
-	/* Retrieve all the results: */
-	child=item->child;
-	while (child && !fail)
-	{
-		ret=print_value(child,depth+1,fmt);
-		entries[i++]=ret;
-		if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
-		child=child->next;
-	}
-	
-	/* If we didn't fail, try to malloc the output string */
-	if (!fail) out=(char*)cJSON_malloc(len);
-	/* If that fails, we fail. */
-	if (!out) fail=1;
-
-	/* Handle failure. */
-	if (fail)
-	{
-		for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
-		cJSON_free(entries);
-		return 0;
-	}
-	
-	/* Compose the output array. */
-	*out='[';
-	ptr=out+1;*ptr=0;
-	for (i=0;i<numentries;i++)
-	{
-		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
-		if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
-		cJSON_free(entries[i]);
-	}
-	cJSON_free(entries);
-	*ptr++=']';*ptr++=0;
-	return out;	
-}
-
-/* Build an object from the text. */
-static const char *parse_object(cJSON *item,const char *value)
-{
-	cJSON *child;
-	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
-	
-	item->type=cJSON_Object;
-	value=skip(value+1);
-	if (*value=='}') return value+1;	/* empty array. */
-	
-	item->child=child=cJSON_New_Item();
-	if (!item->child) return 0;
-	value=skip(parse_string(child,skip(value)));
-	if (!value) return 0;
-	child->string=child->valuestring;child->valuestring=0;
-	if (*value!=':') {ep=value;return 0;}	/* fail! */
-	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
-	if (!value) return 0;
-	
-	while (*value==',')
-	{
-		cJSON *new_item;
-		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
-		child->next=new_item;new_item->prev=child;child=new_item;
-		value=skip(parse_string(child,skip(value+1)));
-		if (!value) return 0;
-		child->string=child->valuestring;child->valuestring=0;
-		if (*value!=':') {ep=value;return 0;}	/* fail! */
-		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
-		if (!value) return 0;
-	}
-	
-	if (*value=='}') return value+1;	/* end of array */
-	ep=value;return 0;	/* malformed. */
-}
-
-/* Render an object to text. */
-static char *print_object(cJSON *item,int depth,int fmt)
-{
-	char **entries=0,**names=0;
-	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
-	cJSON *child=item->child;
-	int numentries=0,fail=0;
-	/* Count the number of entries. */
-	while (child) numentries++,child=child->next;
-	/* Allocate space for the names and the objects */
-	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
-	if (!entries) return 0;
-	names=(char**)cJSON_malloc(numentries*sizeof(char*));
-	if (!names) {cJSON_free(entries);return 0;}
-	memset(entries,0,sizeof(char*)*numentries);
-	memset(names,0,sizeof(char*)*numentries);
-
-	/* Collect all the results into our arrays: */
-	child=item->child;depth++;if (fmt) len+=depth;
-	while (child)
-	{
-		names[i]=str=print_string_ptr(child->string);
-		entries[i++]=ret=print_value(child,depth,fmt);
-		if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
-		child=child->next;
-	}
-	
-	/* Try to allocate the output string */
-	if (!fail) out=(char*)cJSON_malloc(len);
-	if (!out) fail=1;
-
-	/* Handle failure */
-	if (fail)
-	{
-		for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
-		cJSON_free(names);cJSON_free(entries);
-		return 0;
-	}
-	
-	/* Compose the output: */
-	*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
-	for (i=0;i<numentries;i++)
-	{
-		if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
-		strcpy(ptr,names[i]);ptr+=strlen(names[i]);
-		*ptr++=':';if (fmt) *ptr++='\t';
-		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
-		if (i!=numentries-1) *ptr++=',';
-		if (fmt) *ptr++='\n';*ptr=0;
-		cJSON_free(names[i]);cJSON_free(entries[i]);
-	}
-	
-	cJSON_free(names);cJSON_free(entries);
-	if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
-	*ptr++='}';*ptr++=0;
-	return out;	
-}
-
-/* Get Array size/item / object item. */
-int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
-cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
-cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
-
-/* Utility for array list handling. */
-static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
-/* Utility for handling references. */
-static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
-
-/* Add item to array/object. */
-void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
-void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
-void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
-void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
-
-cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
-	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
-void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
-cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
-void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}
-
-/* Replace array/object items with new ones. */
-void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
-	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
-	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
-void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}
-
-/* Create basic types: */
-cJSON *cJSON_CreateNull()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
-cJSON *cJSON_CreateTrue()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
-cJSON *cJSON_CreateFalse()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
-cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
-cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
-cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
-cJSON *cJSON_CreateArray()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
-cJSON *cJSON_CreateObject()						{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
-
-/* Create Arrays: */
-cJSON *cJSON_CreateIntArray(int *numbers,int count)				{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
-cJSON *cJSON_CreateFloatArray(float *numbers,int count)			{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
-cJSON *cJSON_CreateDoubleArray(double *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
-cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
diff --git a/plugins/omelasticsearch/cJSON/cjson.h b/plugins/omelasticsearch/cJSON/cjson.h
deleted file mode 100644
index a621720ce..000000000
--- a/plugins/omelasticsearch/cJSON/cjson.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
-  Copyright (c) 2009 Dave Gamble
- 
-  Permission is hereby granted, free of charge, to any person obtaining a copy
-  of this software and associated documentation files (the "Software"), to deal
-  in the Software without restriction, including without limitation the rights
-  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-  copies of the Software, and to permit persons to whom the Software is
-  furnished to do so, subject to the following conditions:
- 
-  The above copyright notice and this permission notice shall be included in
-  all copies or substantial portions of the Software.
- 
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-  THE SOFTWARE.
-*/
-
-#ifndef cJSON__h
-#define cJSON__h
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-/* cJSON Types: */
-#define cJSON_False 0
-#define cJSON_True 1
-#define cJSON_NULL 2
-#define cJSON_Number 3
-#define cJSON_String 4
-#define cJSON_Array 5
-#define cJSON_Object 6
-	
-#define cJSON_IsReference 256
-
-/* The cJSON structure: */
-typedef struct cJSON {
-	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
-	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
-
-	int type;					/* The type of the item, as above. */
-
-	char *valuestring;			/* The item's string, if type==cJSON_String */
-	int valueint;				/* The item's number, if type==cJSON_Number */
-	double valuedouble;			/* The item's number, if type==cJSON_Number */
-
-	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
-} cJSON;
-
-typedef struct cJSON_Hooks {
-      void *(*malloc_fn)(size_t sz);
-      void (*free_fn)(void *ptr);
-} cJSON_Hooks;
-
-/* Supply malloc, realloc and free functions to cJSON */
-extern void cJSON_InitHooks(cJSON_Hooks* hooks);
-
-
-/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
-extern cJSON *cJSON_Parse(const char *value);
-/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
-extern char  *cJSON_Print(cJSON *item);
-/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
-extern char  *cJSON_PrintUnformatted(cJSON *item);
-/* Delete a cJSON entity and all subentities. */
-extern void   cJSON_Delete(cJSON *c);
-
-/* Returns the number of items in an array (or object). */
-extern int	  cJSON_GetArraySize(cJSON *array);
-/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
-extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
-/* Get item "string" from object. Case insensitive. */
-extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);
-
-/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
-extern const char *cJSON_GetErrorPtr();
-	
-/* These calls create a cJSON item of the appropriate type. */
-extern cJSON *cJSON_CreateNull();
-extern cJSON *cJSON_CreateTrue();
-extern cJSON *cJSON_CreateFalse();
-extern cJSON *cJSON_CreateBool(int b);
-extern cJSON *cJSON_CreateNumber(double num);
-extern cJSON *cJSON_CreateString(const char *string);
-extern cJSON *cJSON_CreateArray();
-extern cJSON *cJSON_CreateObject();
-
-/* These utilities create an Array of count items. */
-extern cJSON *cJSON_CreateIntArray(int *numbers,int count);
-extern cJSON *cJSON_CreateFloatArray(float *numbers,int count);
-extern cJSON *cJSON_CreateDoubleArray(double *numbers,int count);
-extern cJSON *cJSON_CreateStringArray(const char **strings,int count);
-
-/* Append item to the specified array/object. */
-extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
-extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
-/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
-extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
-extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);
-
-/* Remove/Detatch items from Arrays/Objects. */
-extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
-extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
-extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
-extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
-	
-/* Update array items. */
-extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
-extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
-
-/* rger: added helpers */
-
-char *cJSON_print_number(cJSON *item);
-#define cJSON_AddNullToObject(object,name)	cJSON_AddItemToObject(object, name, cJSON_CreateNull())
-#define cJSON_AddTrueToObject(object,name)	cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
-#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
-#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
-#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/plugins/omelasticsearch/omelasticsearch.c b/plugins/omelasticsearch/omelasticsearch.c
index 88bd5e16c..ed2b47535 100644
--- a/plugins/omelasticsearch/omelasticsearch.c
+++ b/plugins/omelasticsearch/omelasticsearch.c
@@ -41,7 +41,7 @@
 #if defined(__FreeBSD__)
 #include <unistd.h>
 #endif
-#include "cJSON/cjson.h"
+#include <json.h>
 #include "conf.h"
 #include "syslogd-types.h"
 #include "srUtils.h"
@@ -626,29 +626,29 @@ finalize_it:
  * Dumps entire bulk request and response in error log
  */
 static rsRetVal
-getDataErrorDefault(wrkrInstanceData_t *pWrkrData,cJSON **pReplyRoot,uchar *reqmsg,char **rendered)
+getDataErrorDefault(wrkrInstanceData_t *pWrkrData,fjson_object **pReplyRoot,uchar *reqmsg,char **rendered)
 {
 	DEFiRet;
-	cJSON *req=0;
-	cJSON *errRoot=0;
-	cJSON *replyRoot = *pReplyRoot;
+	fjson_object *req=NULL;
+	fjson_object *errRoot=NULL;
+	fjson_object *replyRoot = *pReplyRoot;
 
-	if((req=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
-	cJSON_AddItemToObject(req, "url", cJSON_CreateString((char*)pWrkrData->restURL));
-	cJSON_AddItemToObject(req, "postdata", cJSON_CreateString((char*)reqmsg));
+	if((req=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
+	fjson_object_object_add(req, "url", fjson_object_new_string((char*)pWrkrData->restURL));
+	fjson_object_object_add(req, "postdata", fjson_object_new_string((char*)reqmsg));
 
-	if((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
-	cJSON_AddItemToObject(errRoot, "request", req);
-	cJSON_AddItemToObject(errRoot, "reply", replyRoot);
-	*rendered = cJSON_Print(errRoot);
+	if((errRoot=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
+	fjson_object_object_add(errRoot, "request", req);
+	fjson_object_object_add(errRoot, "reply", replyRoot);
+	*rendered = strdup((char*)fjson_object_to_json_string(errRoot));
 
-	req=0;
-	cJSON_Delete(errRoot);
+	req=NULL;
+	fjson_object_put(errRoot);
 
 	*pReplyRoot = NULL; /* tell caller not to delete once again! */
 
 	finalize_it:
-		cJSON_Delete(req);
+		fjson_object_put(req);
 		RETiRet;
 }
 
@@ -703,8 +703,8 @@ finalize_it:
 /*
  * check the status of response from ES
  */
-static int checkReplyStatus(cJSON* ok) {
-	return (ok == NULL || ok->type != cJSON_Number || ok->valueint < 0 || ok->valueint > 299);
+static int checkReplyStatus(fjson_object* ok) {
+	return (ok == NULL || !fjson_object_is_type(ok, fjson_type_int) || fjson_object_get_int(ok) < 0 || fjson_object_get_int(ok) > 299);
 }
 
 /*
@@ -712,7 +712,7 @@ static int checkReplyStatus(cJSON* ok) {
  */
 typedef struct exeContext{
 	int statusCheckOnly;
-	cJSON *errRoot;
+	fjson_object *errRoot;
 	rsRetVal (*prepareErrorFileContent)(struct exeContext *ctx,int itemStatus,char *request,char *response);
 
 
@@ -722,25 +722,24 @@ typedef struct exeContext{
  * get content to be written in error file using context passed
  */
 static rsRetVal
-parseRequestAndResponseForContext(wrkrInstanceData_t *pWrkrData,cJSON **pReplyRoot,uchar *reqmsg,context *ctx)
+parseRequestAndResponseForContext(wrkrInstanceData_t *pWrkrData,fjson_object **pReplyRoot,uchar *reqmsg,context *ctx)
 {
 	DEFiRet;
-	cJSON *replyRoot = *pReplyRoot;
+	fjson_object *replyRoot = *pReplyRoot;
 	int i;
 	int numitems;
-	cJSON *items=0;
+	fjson_object *items=NULL;
 
 
 	/*iterate over items*/
-	items = cJSON_GetObjectItem(replyRoot, "items");
-	if(items == NULL || items->type != cJSON_Array) {
+	if(!fjson_object_object_get_ex(replyRoot, "items", &items)) {
 		DBGPRINTF("omelasticsearch: error in elasticsearch reply: "
 			  "bulkmode insert does not return array, reply is: %s\n",
 			  pWrkrData->reply);
 		ABORT_FINALIZE(RS_RET_DATAFAIL);
 	}
 
-	numitems = cJSON_GetArraySize(items);
+	numitems = fjson_object_array_length(items);
 
 	DBGPRINTF("omelasticsearch: Entire request %s\n",reqmsg);
 	const char *lastReqRead= (char*)reqmsg;
@@ -748,32 +747,32 @@ parseRequestAndResponseForContext(wrkrInstanceData_t *pWrkrData,cJSON **pReplyRo
 	DBGPRINTF("omelasticsearch: %d items in reply\n", numitems);
 	for(i = 0 ; i < numitems ; ++i) {
 
-		cJSON *item=0;
-		cJSON *result=0;
-		cJSON *ok=0;
+		fjson_object *item=NULL;
+		fjson_object *result=NULL;
+		fjson_object *ok=NULL;
 		int itemStatus=0;
-		item = cJSON_GetArrayItem(items, i);
+		item = fjson_object_array_get_idx(items, i);
 		if(item == NULL)  {
 			DBGPRINTF("omelasticsearch: error in elasticsearch reply: "
 				  "cannot obtain reply array item %d\n", i);
 			ABORT_FINALIZE(RS_RET_DATAFAIL);
 		}
-		result = item->child;
-		if(result == NULL || result->type != cJSON_Object) {
+		fjson_object_object_get_ex(item, "create", &result);
+		if(result == NULL || !fjson_object_is_type(result, fjson_type_object)) {
 			DBGPRINTF("omelasticsearch: error in elasticsearch reply: "
 				  "cannot obtain 'result' item for #%d\n", i);
 			ABORT_FINALIZE(RS_RET_DATAFAIL);
 		}
 
-		ok = cJSON_GetObjectItem(result, "status");
+		fjson_object_object_get_ex(result, "status", &ok);
 		itemStatus = checkReplyStatus(ok);
-
+		
 		char *request =0;
 		char *response =0;
 		if(ctx->statusCheckOnly)
 		{
 			if(itemStatus) {
-				DBGPRINTF("omelasticsearch: error in elasticsearch reply: item %d, status is %d\n", i, ok->valueint);
+				DBGPRINTF("omelasticsearch: error in elasticsearch reply: item %d, status is %d\n", i, fjson_object_get_int(ok));
 				DBGPRINTF("omelasticsearch: status check found error.\n");
 				ABORT_FINALIZE(RS_RET_DATAFAIL);
 			}
@@ -786,13 +785,12 @@ parseRequestAndResponseForContext(wrkrInstanceData_t *pWrkrData,cJSON **pReplyRo
 				DBGPRINTF("omelasticsearch: Couldn't get post request\n");
 				ABORT_FINALIZE(RS_RET_ERR);
 			}
-
-			response = cJSON_PrintUnformatted(result);
+			response = (char*)fjson_object_to_json_string_ext(result, FJSON_TO_STRING_PLAIN);
 
 			if(response==NULL)
 			{
 				free(request);/*as its has been assigned.*/
-				DBGPRINTF("omelasticsearch: Error getting cJSON_PrintUnformatted. Cannot continue\n");
+				DBGPRINTF("omelasticsearch: Error getting fjson_object_to_string_ext. Cannot continue\n");
 				ABORT_FINALIZE(RS_RET_ERR);
 			}
 
@@ -801,7 +799,6 @@ parseRequestAndResponseForContext(wrkrInstanceData_t *pWrkrData,cJSON **pReplyRo
 
 			/*free memory in any case*/
 			free(request);
-			free(response);
 
 			if(ret != RS_RET_OK)
 			{
@@ -826,23 +823,23 @@ getDataErrorOnly(context *ctx,int itemStatus,char *request,char *response)
 	DEFiRet;
 	if(itemStatus)
 	{
-		cJSON *onlyErrorResponses =0;
-		cJSON *onlyErrorRequests=0;
+		fjson_object *onlyErrorResponses =NULL;
+		fjson_object *onlyErrorRequests=NULL;
 
-		if((onlyErrorResponses=cJSON_GetObjectItem(ctx->errRoot, "reply")) == NULL)
+		if(!fjson_object_object_get_ex(ctx->errRoot, "reply", &onlyErrorResponses))
 		{
 			DBGPRINTF("omelasticsearch: Failed to get reply json array. Invalid context. Cannot continue\n");
 			ABORT_FINALIZE(RS_RET_ERR);
 		}
-		cJSON_AddItemToArray(onlyErrorResponses, cJSON_CreateString(response));
+		fjson_object_array_add(onlyErrorResponses, fjson_object_new_string(response));
 
-		if((onlyErrorRequests=cJSON_GetObjectItem(ctx->errRoot, "request")) == NULL)
+		if(!fjson_object_object_get_ex(ctx->errRoot, "request", &onlyErrorRequests))
 		{
 			DBGPRINTF("omelasticsearch: Failed to get request json array. Invalid context. Cannot continue\n");
 			ABORT_FINALIZE(RS_RET_ERR);
 		}
 
-		cJSON_AddItemToArray(onlyErrorRequests, cJSON_CreateString(request));
+		fjson_object_array_add(onlyErrorRequests, fjson_object_new_string(request));
 
 	}
 
@@ -861,24 +858,24 @@ getDataInterleaved(context *ctx,
 	char *response)
 {
 	DEFiRet;
-	cJSON *interleaved =0;
-	if((interleaved=cJSON_GetObjectItem(ctx->errRoot, "response")) == NULL)
+	fjson_object *interleaved =NULL;
+	if(!fjson_object_object_get_ex(ctx->errRoot, "response", &interleaved))
 	{
 		DBGPRINTF("omelasticsearch: Failed to get response json array. Invalid context. Cannot continue\n");
 		ABORT_FINALIZE(RS_RET_ERR);
 	}
 
-	cJSON *interleavedNode=0;
+	fjson_object *interleavedNode=NULL;
 	/*create interleaved node that has req and response json data*/
-	if((interleavedNode=cJSON_CreateObject()) == NULL)
+	if((interleavedNode=fjson_object_new_object()) == NULL)
 	{
 		DBGPRINTF("omelasticsearch: Failed to create interleaved node. Cann't continue\n");
 		ABORT_FINALIZE(RS_RET_ERR);
 	}
-	cJSON_AddItemToObject(interleavedNode,"request", cJSON_CreateString(request));
-	cJSON_AddItemToObject(interleavedNode,"reply", cJSON_CreateString(response));
+	fjson_object_object_add(interleavedNode,"request", fjson_object_new_string(request));
+	fjson_object_object_add(interleavedNode,"reply", fjson_object_new_string(response));
 
-	cJSON_AddItemToArray(interleaved, interleavedNode);
+	fjson_object_array_add(interleaved, interleavedNode);
 
 
 
@@ -912,24 +909,24 @@ static rsRetVal
 initializeErrorOnlyConext(wrkrInstanceData_t *pWrkrData,context *ctx){
 	DEFiRet;
 	ctx->statusCheckOnly=0;
-	cJSON *errRoot=0;
-	cJSON *onlyErrorResponses =0;
-	cJSON *onlyErrorRequests=0;
-	if((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
+	fjson_object *errRoot=NULL;
+	fjson_object *onlyErrorResponses =NULL;
+	fjson_object *onlyErrorRequests=NULL;
+	if((errRoot=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
 
-	if((onlyErrorResponses=cJSON_CreateArray()) == NULL) {
-		cJSON_Delete(errRoot);
+	if((onlyErrorResponses=fjson_object_new_array()) == NULL) {
+		fjson_object_put(errRoot);
 		ABORT_FINALIZE(RS_RET_ERR);
 	}
-	if((onlyErrorRequests=cJSON_CreateArray()) == NULL) {
-		cJSON_Delete(errRoot);
-		cJSON_Delete(onlyErrorResponses);
+	if((onlyErrorRequests=fjson_object_new_array()) == NULL) {
+		fjson_object_put(errRoot);
+		fjson_object_put(onlyErrorResponses);
 		ABORT_FINALIZE(RS_RET_ERR);
 	}
 
-	cJSON_AddItemToObject(errRoot, "url", cJSON_CreateString((char*)pWrkrData->restURL));
-	cJSON_AddItemToObject(errRoot,"request",onlyErrorRequests);
-	cJSON_AddItemToObject(errRoot, "reply", onlyErrorResponses);
+	fjson_object_object_add(errRoot, "url", fjson_object_new_string((char*)pWrkrData->restURL));
+	fjson_object_object_add(errRoot,"request",onlyErrorRequests);
+	fjson_object_object_add(errRoot, "reply", onlyErrorResponses);
 	ctx->errRoot = errRoot;
 	ctx->prepareErrorFileContent= &getDataErrorOnly;
 	finalize_it:
@@ -943,17 +940,17 @@ static rsRetVal
 initializeInterleavedConext(wrkrInstanceData_t *pWrkrData,context *ctx){
 	DEFiRet;
 	ctx->statusCheckOnly=0;
-	cJSON *errRoot=0;
-	cJSON *interleaved =0;
-	if((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
-	if((interleaved=cJSON_CreateArray()) == NULL) {
-		cJSON_Delete(errRoot);
+	fjson_object *errRoot=NULL;
+	fjson_object *interleaved =NULL;
+	if((errRoot=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
+	if((interleaved=fjson_object_new_array()) == NULL) {
+		fjson_object_put(errRoot);
 		ABORT_FINALIZE(RS_RET_ERR);
 	}
 
 
-	cJSON_AddItemToObject(errRoot, "url", cJSON_CreateString((char*)pWrkrData->restURL));
-	cJSON_AddItemToObject(errRoot,"response",interleaved);
+	fjson_object_object_add(errRoot, "url", fjson_object_new_string((char*)pWrkrData->restURL));
+	fjson_object_object_add(errRoot,"response",interleaved);
 	ctx->errRoot = errRoot;
 	ctx->prepareErrorFileContent= &getDataInterleaved;
 	finalize_it:
@@ -965,17 +962,17 @@ static rsRetVal
 initializeErrorInterleavedConext(wrkrInstanceData_t *pWrkrData,context *ctx){
 	DEFiRet;
 	ctx->statusCheckOnly=0;
-	cJSON *errRoot=0;
-	cJSON *interleaved =0;
-	if((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
-	if((interleaved=cJSON_CreateArray()) == NULL) {
-		cJSON_Delete(errRoot);
+	fjson_object *errRoot=NULL;
+	fjson_object *interleaved =NULL;
+	if((errRoot=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
+	if((interleaved=fjson_object_new_array()) == NULL) {
+		fjson_object_put(errRoot);
 		ABORT_FINALIZE(RS_RET_ERR);
 	}
 
 
-	cJSON_AddItemToObject(errRoot, "url", cJSON_CreateString((char*)pWrkrData->restURL));
-	cJSON_AddItemToObject(errRoot,"response",interleaved);
+	fjson_object_object_add(errRoot, "url", fjson_object_new_string((char*)pWrkrData->restURL));
+	fjson_object_object_add(errRoot,"response",interleaved);
 	ctx->errRoot = errRoot;
 	ctx->prepareErrorFileContent= &getDataErrorOnlyInterleaved;
 	finalize_it:
@@ -988,7 +985,7 @@ initializeErrorInterleavedConext(wrkrInstanceData_t *pWrkrData,context *ctx){
  * needs to be closed, HUP must be sent.
  */
 static rsRetVal
-writeDataError(wrkrInstanceData_t *pWrkrData, instanceData *pData, cJSON **pReplyRoot, uchar *reqmsg)
+writeDataError(wrkrInstanceData_t *pWrkrData, instanceData *pData, fjson_object **pReplyRoot, uchar *reqmsg)
 {
 	char *rendered = NULL;
 	size_t toWrite;
@@ -1054,7 +1051,7 @@ writeDataError(wrkrInstanceData_t *pWrkrData, instanceData *pData, cJSON **pRepl
 			DBGPRINTF("omelasticsearch: error creating file content.\n");
 			ABORT_FINALIZE(RS_RET_ERR);
 		}
-		rendered = cJSON_Print(ctx.errRoot);
+		rendered = (char*)fjson_object_to_json_string(ctx.errRoot);
 	}
 
 
@@ -1084,14 +1081,13 @@ writeDataError(wrkrInstanceData_t *pWrkrData, instanceData *pData, cJSON **pRepl
 finalize_it:
 	if(bMutLocked)
 		pthread_mutex_unlock(&pData->mutErrFile);
-	cJSON_Delete(ctx.errRoot);
-	free(rendered);
+	fjson_object_put(ctx.errRoot);
 	RETiRet;
 }
 
 
 static rsRetVal
-checkResultBulkmode(wrkrInstanceData_t *pWrkrData, cJSON *root)
+checkResultBulkmode(wrkrInstanceData_t *pWrkrData, fjson_object *root)
 {
 	DEFiRet;
 	context ctx;
@@ -1111,11 +1107,11 @@ checkResultBulkmode(wrkrInstanceData_t *pWrkrData, cJSON *root)
 static rsRetVal
 checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
 {
-	cJSON *root;
-	cJSON *status;
+	fjson_object *root;
+	fjson_object *status;
 	DEFiRet;
 
-	root = cJSON_Parse(pWrkrData->reply);
+	root = fjson_tokener_parse(pWrkrData->reply);
 	if(root == NULL) {
 		DBGPRINTF("omelasticsearch: could not parse JSON result \n");
 		ABORT_FINALIZE(RS_RET_ERR);
@@ -1124,10 +1120,7 @@ checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
 	if(pWrkrData->pData->bulkmode) {
 		iRet = checkResultBulkmode(pWrkrData, root);
 	} else {
-		status = cJSON_GetObjectItem(root, "status");
-		/* as far as we know, no "status" means all went well */
-		if(status != NULL &&
-		   (status->type == cJSON_Number || status->valueint >= 0 || status->valueint <= 299)) {
+		if(fjson_object_object_get_ex(root, "status", &status)) {
 			iRet = RS_RET_DATAFAIL;
 		}
 	}
@@ -1143,7 +1136,7 @@ checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
 
 finalize_it:
 	if(root != NULL)
-		cJSON_Delete(root);
+		fjson_object_put(root);
 	if(iRet != RS_RET_OK) {
 		STATSCOUNTER_INC(indexESFail, mutIndexESFail);
 	}
diff --git a/tests/es-bulk-errfile-empty.sh b/tests/es-bulk-errfile-empty.sh
index 1f27f62fe..95883cb3d 100755
--- a/tests/es-bulk-errfile-empty.sh
+++ b/tests/es-bulk-errfile-empty.sh
@@ -12,6 +12,7 @@ echo \[es-bulk-errfile-empty\]: basic test for elasticsearch functionality
 if [ -f rsyslog.errorfile ]
 then
     echo "error: error file exists!"
+    cat rsyslog.errorfile
     exit 1
 fi
 . $srcdir/diag.sh seq-check  0 9999
-- 
2.14.4

